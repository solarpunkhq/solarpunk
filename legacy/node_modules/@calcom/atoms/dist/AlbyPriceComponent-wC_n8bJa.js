import { aI as ee, aJ as F, aK as re, a6 as ne, aL as te } from "./index-6PQ0n_zn.js";
import K from "react";
import { jsx as J, jsxs as oe } from "react/jsx-runtime";
var ie = { exports: {} }, D = { exports: {} };
const ae = {}, se = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: ae
}, Symbol.toStringTag, { value: "Module" })), ce = /* @__PURE__ */ ee(se);
var Q;
function Z() {
  return Q || (Q = 1, function(o, v) {
    (function(l, w) {
      o.exports = w();
    })(F, function() {
      var l = l || function(w, m) {
        var b;
        if (typeof window < "u" && window.crypto && (b = window.crypto), typeof self < "u" && self.crypto && (b = self.crypto), typeof globalThis < "u" && globalThis.crypto && (b = globalThis.crypto), !b && typeof window < "u" && window.msCrypto && (b = window.msCrypto), !b && typeof F < "u" && F.crypto && (b = F.crypto), !b && typeof re == "function")
          try {
            b = ce;
          } catch {
          }
        var N = function() {
          if (b) {
            if (typeof b.getRandomValues == "function")
              try {
                return b.getRandomValues(new Uint32Array(1))[0];
              } catch {
              }
            if (typeof b.randomBytes == "function")
              try {
                return b.randomBytes(4).readInt32LE();
              } catch {
              }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, I = Object.create || /* @__PURE__ */ function() {
          function t() {
          }
          return function(i) {
            var f;
            return t.prototype = i, f = new t(), t.prototype = null, f;
          };
        }(), L = {}, H = L.lib = {}, U = H.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(t) {
              var i = I(this);
              return t && i.mixIn(t), (!i.hasOwnProperty("init") || this.init === i.init) && (i.init = function() {
                i.$super.init.apply(this, arguments);
              }), i.init.prototype = i, i.$super = this, i;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var t = this.extend();
              return t.init.apply(t, arguments), t;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(t) {
              for (var i in t)
                t.hasOwnProperty(i) && (this[i] = t[i]);
              t.hasOwnProperty("toString") && (this.toString = t.toString);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }(), B = H.WordArray = U.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(t, i) {
            t = this.words = t || [], i != m ? this.sigBytes = i : this.sigBytes = t.length * 4;
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(t) {
            return (t || C).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(t) {
            var i = this.words, f = t.words, d = this.sigBytes, E = t.sigBytes;
            if (this.clamp(), d % 4)
              for (var p = 0; p < E; p++) {
                var _ = f[p >>> 2] >>> 24 - p % 4 * 8 & 255;
                i[d + p >>> 2] |= _ << 24 - (d + p) % 4 * 8;
              }
            else
              for (var A = 0; A < E; A += 4)
                i[d + A >>> 2] = f[A >>> 2];
            return this.sigBytes += E, this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var t = this.words, i = this.sigBytes;
            t[i >>> 2] &= 4294967295 << 32 - i % 4 * 8, t.length = w.ceil(i / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var t = U.clone.call(this);
            return t.words = this.words.slice(0), t;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(t) {
            for (var i = [], f = 0; f < t; f += 4)
              i.push(N());
            return new B.init(i, t);
          }
        }), S = L.enc = {}, C = S.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(t) {
            for (var i = t.words, f = t.sigBytes, d = [], E = 0; E < f; E++) {
              var p = i[E >>> 2] >>> 24 - E % 4 * 8 & 255;
              d.push((p >>> 4).toString(16)), d.push((p & 15).toString(16));
            }
            return d.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(t) {
            for (var i = t.length, f = [], d = 0; d < i; d += 2)
              f[d >>> 3] |= parseInt(t.substr(d, 2), 16) << 24 - d % 8 * 4;
            return new B.init(f, i / 2);
          }
        }, $ = S.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(t) {
            for (var i = t.words, f = t.sigBytes, d = [], E = 0; E < f; E++) {
              var p = i[E >>> 2] >>> 24 - E % 4 * 8 & 255;
              d.push(String.fromCharCode(p));
            }
            return d.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(t) {
            for (var i = t.length, f = [], d = 0; d < i; d++)
              f[d >>> 2] |= (t.charCodeAt(d) & 255) << 24 - d % 4 * 8;
            return new B.init(f, i);
          }
        }, h = S.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(t) {
            try {
              return decodeURIComponent(escape($.stringify(t)));
            } catch {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(t) {
            return $.parse(unescape(encodeURIComponent(t)));
          }
        }, g = H.BufferedBlockAlgorithm = U.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new B.init(), this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(t) {
            typeof t == "string" && (t = h.parse(t)), this._data.concat(t), this._nDataBytes += t.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(t) {
            var i, f = this._data, d = f.words, E = f.sigBytes, p = this.blockSize, _ = p * 4, A = E / _;
            t ? A = w.ceil(A) : A = w.max((A | 0) - this._minBufferSize, 0);
            var W = A * p, e = w.min(W * 4, E);
            if (W) {
              for (var r = 0; r < W; r += p)
                this._doProcessBlock(d, r);
              i = d.splice(0, W), f.sigBytes -= e;
            }
            return new B.init(i, e);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var t = U.clone.call(this);
            return t._data = this._data.clone(), t;
          },
          _minBufferSize: 0
        });
        H.Hasher = g.extend({
          /**
           * Configuration options.
           */
          cfg: U.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(t) {
            this.cfg = this.cfg.extend(t), this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            g.reset.call(this), this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(t) {
            return this._append(t), this._process(), this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(t) {
            t && this._append(t);
            var i = this._doFinalize();
            return i;
          },
          blockSize: 16,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(t) {
            return function(i, f) {
              return new t.init(f).finalize(i);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(t) {
            return function(i, f) {
              return new k.HMAC.init(t, f).finalize(i);
            };
          }
        });
        var k = L.algo = {};
        return L;
      }(Math);
      return l;
    });
  }(D)), D.exports;
}
(function(o, v) {
  (function(l, w) {
    o.exports = w(Z());
  })(F, function(l) {
    return l.enc.Hex;
  });
})(ie);
var fe = { exports: {} };
(function(o, v) {
  (function(l, w) {
    o.exports = w(Z());
  })(F, function(l) {
    return function(w) {
      var m = l, b = m.lib, N = b.WordArray, I = b.Hasher, L = m.algo, H = [], U = [];
      (function() {
        function C(k) {
          for (var t = w.sqrt(k), i = 2; i <= t; i++)
            if (!(k % i))
              return !1;
          return !0;
        }
        function $(k) {
          return (k - (k | 0)) * 4294967296 | 0;
        }
        for (var h = 2, g = 0; g < 64; )
          C(h) && (g < 8 && (H[g] = $(w.pow(h, 1 / 2))), U[g] = $(w.pow(h, 1 / 3)), g++), h++;
      })();
      var B = [], S = L.SHA256 = I.extend({
        _doReset: function() {
          this._hash = new N.init(H.slice(0));
        },
        _doProcessBlock: function(C, $) {
          for (var h = this._hash.words, g = h[0], k = h[1], t = h[2], i = h[3], f = h[4], d = h[5], E = h[6], p = h[7], _ = 0; _ < 64; _++) {
            if (_ < 16)
              B[_] = C[$ + _] | 0;
            else {
              var A = B[_ - 15], W = (A << 25 | A >>> 7) ^ (A << 14 | A >>> 18) ^ A >>> 3, e = B[_ - 2], r = (e << 15 | e >>> 17) ^ (e << 13 | e >>> 19) ^ e >>> 10;
              B[_] = W + B[_ - 7] + r + B[_ - 16];
            }
            var n = f & d ^ ~f & E, c = g & k ^ g & t ^ k & t, a = (g << 30 | g >>> 2) ^ (g << 19 | g >>> 13) ^ (g << 10 | g >>> 22), s = (f << 26 | f >>> 6) ^ (f << 21 | f >>> 11) ^ (f << 7 | f >>> 25), u = p + s + n + U[_] + B[_], T = a + c;
            p = E, E = d, d = f, f = i + u | 0, i = t, t = k, k = g, g = u + T | 0;
          }
          h[0] = h[0] + g | 0, h[1] = h[1] + k | 0, h[2] = h[2] + t | 0, h[3] = h[3] + i | 0, h[4] = h[4] + f | 0, h[5] = h[5] + d | 0, h[6] = h[6] + E | 0, h[7] = h[7] + p | 0;
        },
        _doFinalize: function() {
          var C = this._data, $ = C.words, h = this._nDataBytes * 8, g = C.sigBytes * 8;
          return $[g >>> 5] |= 128 << 24 - g % 32, $[(g + 64 >>> 9 << 4) + 14] = w.floor(h / 4294967296), $[(g + 64 >>> 9 << 4) + 15] = h, C.sigBytes = $.length * 4, this._process(), this._hash;
        },
        clone: function() {
          var C = I.clone.call(this);
          return C._hash = this._hash.clone(), C;
        }
      });
      m.SHA256 = I._createHelper(S), m.HmacSHA256 = I._createHmacHelper(S);
    }(Math), l.SHA256;
  });
})(fe);
var ue = {};
(function(o) {
  /*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
  Object.defineProperty(o, "__esModule", { value: !0 }), o.bytes = o.stringToBytes = o.str = o.bytesToString = o.hex = o.utf8 = o.bech32m = o.bech32 = o.base58check = o.base58xmr = o.base58xrp = o.base58flickr = o.base58 = o.base64url = o.base64 = o.base32crockford = o.base32hex = o.base32 = o.base16 = o.utils = o.assertNumber = void 0;
  function v(e) {
    if (!Number.isSafeInteger(e))
      throw new Error(`Wrong integer: ${e}`);
  }
  o.assertNumber = v;
  function l(...e) {
    const r = (a, s) => (u) => a(s(u)), n = Array.from(e).reverse().reduce((a, s) => a ? r(a, s.encode) : s.encode, void 0), c = e.reduce((a, s) => a ? r(a, s.decode) : s.decode, void 0);
    return { encode: n, decode: c };
  }
  function w(e) {
    return {
      encode: (r) => {
        if (!Array.isArray(r) || r.length && typeof r[0] != "number")
          throw new Error("alphabet.encode input should be an array of numbers");
        return r.map((n) => {
          if (v(n), n < 0 || n >= e.length)
            throw new Error(`Digit index outside alphabet: ${n} (alphabet: ${e.length})`);
          return e[n];
        });
      },
      decode: (r) => {
        if (!Array.isArray(r) || r.length && typeof r[0] != "string")
          throw new Error("alphabet.decode input should be array of strings");
        return r.map((n) => {
          if (typeof n != "string")
            throw new Error(`alphabet.decode: not string element=${n}`);
          const c = e.indexOf(n);
          if (c === -1)
            throw new Error(`Unknown letter: "${n}". Allowed: ${e}`);
          return c;
        });
      }
    };
  }
  function m(e = "") {
    if (typeof e != "string")
      throw new Error("join separator should be string");
    return {
      encode: (r) => {
        if (!Array.isArray(r) || r.length && typeof r[0] != "string")
          throw new Error("join.encode input should be array of strings");
        for (let n of r)
          if (typeof n != "string")
            throw new Error(`join.encode: non-string input=${n}`);
        return r.join(e);
      },
      decode: (r) => {
        if (typeof r != "string")
          throw new Error("join.decode input should be string");
        return r.split(e);
      }
    };
  }
  function b(e, r = "=") {
    if (v(e), typeof r != "string")
      throw new Error("padding chr should be string");
    return {
      encode(n) {
        if (!Array.isArray(n) || n.length && typeof n[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let c of n)
          if (typeof c != "string")
            throw new Error(`padding.encode: non-string input=${c}`);
        for (; n.length * e % 8; )
          n.push(r);
        return n;
      },
      decode(n) {
        if (!Array.isArray(n) || n.length && typeof n[0] != "string")
          throw new Error("padding.encode input should be array of strings");
        for (let a of n)
          if (typeof a != "string")
            throw new Error(`padding.decode: non-string input=${a}`);
        let c = n.length;
        if (c * e % 8)
          throw new Error("Invalid padding: string should have whole number of bytes");
        for (; c > 0 && n[c - 1] === r; c--)
          if (!((c - 1) * e % 8))
            throw new Error("Invalid padding: string has too much padding");
        return n.slice(0, c);
      }
    };
  }
  function N(e) {
    if (typeof e != "function")
      throw new Error("normalize fn should be function");
    return { encode: (r) => r, decode: (r) => e(r) };
  }
  function I(e, r, n) {
    if (r < 2)
      throw new Error(`convertRadix: wrong from=${r}, base cannot be less than 2`);
    if (n < 2)
      throw new Error(`convertRadix: wrong to=${n}, base cannot be less than 2`);
    if (!Array.isArray(e))
      throw new Error("convertRadix: data should be array");
    if (!e.length)
      return [];
    let c = 0;
    const a = [], s = Array.from(e);
    for (s.forEach((u) => {
      if (v(u), u < 0 || u >= r)
        throw new Error(`Wrong integer: ${u}`);
    }); ; ) {
      let u = 0, T = !0;
      for (let x = c; x < s.length; x++) {
        const P = s[x], y = r * u + P;
        if (!Number.isSafeInteger(y) || r * u / r !== u || y - P !== r * u)
          throw new Error("convertRadix: carry overflow");
        if (u = y % n, s[x] = Math.floor(y / n), !Number.isSafeInteger(s[x]) || s[x] * n + u !== y)
          throw new Error("convertRadix: carry overflow");
        if (T)
          s[x] ? T = !1 : c = x;
        else
          continue;
      }
      if (a.push(u), T)
        break;
    }
    for (let u = 0; u < e.length - 1 && e[u] === 0; u++)
      a.push(0);
    return a.reverse();
  }
  const L = (e, r) => r ? L(r, e % r) : e, H = (e, r) => e + (r - L(e, r));
  function U(e, r, n, c) {
    if (!Array.isArray(e))
      throw new Error("convertRadix2: data should be array");
    if (r <= 0 || r > 32)
      throw new Error(`convertRadix2: wrong from=${r}`);
    if (n <= 0 || n > 32)
      throw new Error(`convertRadix2: wrong to=${n}`);
    if (H(r, n) > 32)
      throw new Error(`convertRadix2: carry overflow from=${r} to=${n} carryBits=${H(r, n)}`);
    let a = 0, s = 0;
    const u = 2 ** n - 1, T = [];
    for (const x of e) {
      if (v(x), x >= 2 ** r)
        throw new Error(`convertRadix2: invalid data word=${x} from=${r}`);
      if (a = a << r | x, s + r > 32)
        throw new Error(`convertRadix2: carry overflow pos=${s} from=${r}`);
      for (s += r; s >= n; s -= n)
        T.push((a >> s - n & u) >>> 0);
      a &= 2 ** s - 1;
    }
    if (a = a << n - s & u, !c && s >= r)
      throw new Error("Excess padding");
    if (!c && a)
      throw new Error(`Non-zero padding: ${a}`);
    return c && s > 0 && T.push(a >>> 0), T;
  }
  function B(e) {
    return v(e), {
      encode: (r) => {
        if (!(r instanceof Uint8Array))
          throw new Error("radix.encode input should be Uint8Array");
        return I(Array.from(r), 2 ** 8, e);
      },
      decode: (r) => {
        if (!Array.isArray(r) || r.length && typeof r[0] != "number")
          throw new Error("radix.decode input should be array of strings");
        return Uint8Array.from(I(r, e, 2 ** 8));
      }
    };
  }
  function S(e, r = !1) {
    if (v(e), e <= 0 || e > 32)
      throw new Error("radix2: bits should be in (0..32]");
    if (H(8, e) > 32 || H(e, 8) > 32)
      throw new Error("radix2: carry overflow");
    return {
      encode: (n) => {
        if (!(n instanceof Uint8Array))
          throw new Error("radix2.encode input should be Uint8Array");
        return U(Array.from(n), 8, e, !r);
      },
      decode: (n) => {
        if (!Array.isArray(n) || n.length && typeof n[0] != "number")
          throw new Error("radix2.decode input should be array of strings");
        return Uint8Array.from(U(n, e, 8, r));
      }
    };
  }
  function C(e) {
    if (typeof e != "function")
      throw new Error("unsafeWrapper fn should be function");
    return function(...r) {
      try {
        return e.apply(null, r);
      } catch {
      }
    };
  }
  function $(e, r) {
    if (v(e), typeof r != "function")
      throw new Error("checksum fn should be function");
    return {
      encode(n) {
        if (!(n instanceof Uint8Array))
          throw new Error("checksum.encode: input should be Uint8Array");
        const c = r(n).slice(0, e), a = new Uint8Array(n.length + e);
        return a.set(n), a.set(c, n.length), a;
      },
      decode(n) {
        if (!(n instanceof Uint8Array))
          throw new Error("checksum.decode: input should be Uint8Array");
        const c = n.slice(0, -e), a = r(c).slice(0, e), s = n.slice(-e);
        for (let u = 0; u < e; u++)
          if (a[u] !== s[u])
            throw new Error("Invalid checksum");
        return c;
      }
    };
  }
  o.utils = { alphabet: w, chain: l, checksum: $, radix: B, radix2: S, join: m, padding: b }, o.base16 = l(S(4), w("0123456789ABCDEF"), m("")), o.base32 = l(S(5), w("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), b(5), m("")), o.base32hex = l(S(5), w("0123456789ABCDEFGHIJKLMNOPQRSTUV"), b(5), m("")), o.base32crockford = l(S(5), w("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), m(""), N((e) => e.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1"))), o.base64 = l(S(6), w("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), b(6), m("")), o.base64url = l(S(6), w("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), b(6), m(""));
  const h = (e) => l(B(58), w(e), m(""));
  o.base58 = h("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"), o.base58flickr = h("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"), o.base58xrp = h("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
  const g = [0, 2, 3, 5, 6, 7, 9, 10, 11];
  o.base58xmr = {
    encode(e) {
      let r = "";
      for (let n = 0; n < e.length; n += 8) {
        const c = e.subarray(n, n + 8);
        r += o.base58.encode(c).padStart(g[c.length], "1");
      }
      return r;
    },
    decode(e) {
      let r = [];
      for (let n = 0; n < e.length; n += 11) {
        const c = e.slice(n, n + 11), a = g.indexOf(c.length), s = o.base58.decode(c);
        for (let u = 0; u < s.length - a; u++)
          if (s[u] !== 0)
            throw new Error("base58xmr: wrong padding");
        r = r.concat(Array.from(s.slice(s.length - a)));
      }
      return Uint8Array.from(r);
    }
  };
  const k = (e) => l($(4, (r) => e(e(r))), o.base58);
  o.base58check = k;
  const t = l(w("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), m("")), i = [996825010, 642813549, 513874426, 1027748829, 705979059];
  function f(e) {
    const r = e >> 25;
    let n = (e & 33554431) << 5;
    for (let c = 0; c < i.length; c++)
      (r >> c & 1) === 1 && (n ^= i[c]);
    return n;
  }
  function d(e, r, n = 1) {
    const c = e.length;
    let a = 1;
    for (let s = 0; s < c; s++) {
      const u = e.charCodeAt(s);
      if (u < 33 || u > 126)
        throw new Error(`Invalid prefix (${e})`);
      a = f(a) ^ u >> 5;
    }
    a = f(a);
    for (let s = 0; s < c; s++)
      a = f(a) ^ e.charCodeAt(s) & 31;
    for (let s of r)
      a = f(a) ^ s;
    for (let s = 0; s < 6; s++)
      a = f(a);
    return a ^= n, t.encode(U([a % 2 ** 30], 30, 5, !1));
  }
  function E(e) {
    const r = e === "bech32" ? 1 : 734539939, n = S(5), c = n.decode, a = n.encode, s = C(c);
    function u(y, R, O = 90) {
      if (typeof y != "string")
        throw new Error(`bech32.encode prefix should be string, not ${typeof y}`);
      if (!Array.isArray(R) || R.length && typeof R[0] != "number")
        throw new Error(`bech32.encode words should be array of numbers, not ${typeof R}`);
      const j = y.length + 7 + R.length;
      if (O !== !1 && j > O)
        throw new TypeError(`Length ${j} exceeds limit ${O}`);
      return y = y.toLowerCase(), `${y}1${t.encode(R)}${d(y, R, r)}`;
    }
    function T(y, R = 90) {
      if (typeof y != "string")
        throw new Error(`bech32.decode input should be string, not ${typeof y}`);
      if (y.length < 8 || R !== !1 && y.length > R)
        throw new TypeError(`Wrong string length: ${y.length} (${y}). Expected (8..${R})`);
      const O = y.toLowerCase();
      if (y !== O && y !== y.toUpperCase())
        throw new Error("String must be lowercase or uppercase");
      y = O;
      const j = y.lastIndexOf("1");
      if (j === 0 || j === -1)
        throw new Error('Letter "1" must be present between prefix and data only');
      const q = y.slice(0, j), z = y.slice(j + 1);
      if (z.length < 6)
        throw new Error("Data must be at least 6 characters long");
      const G = t.decode(z).slice(0, -6), M = d(q, G, r);
      if (!z.endsWith(M))
        throw new Error(`Invalid checksum in ${y}: expected "${M}"`);
      return { prefix: q, words: G };
    }
    const x = C(T);
    function P(y) {
      const { prefix: R, words: O } = T(y, !1);
      return { prefix: R, words: O, bytes: c(O) };
    }
    return { encode: u, decode: T, decodeToBytes: P, decodeUnsafe: x, fromWords: c, fromWordsUnsafe: s, toWords: a };
  }
  o.bech32 = E("bech32"), o.bech32m = E("bech32m"), o.utf8 = {
    encode: (e) => new TextDecoder().decode(e),
    decode: (e) => new TextEncoder().encode(e)
  }, o.hex = l(S(4), w("0123456789abcdef"), m(""), N((e) => {
    if (typeof e != "string" || e.length % 2)
      throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);
    return e.toLowerCase();
  }));
  const p = {
    utf8: o.utf8,
    hex: o.hex,
    base16: o.base16,
    base32: o.base32,
    base64: o.base64,
    base64url: o.base64url,
    base58: o.base58,
    base58xmr: o.base58xmr
  }, _ = `Invalid encoding type. Available types: ${Object.keys(p).join(", ")}`, A = (e, r) => {
    if (typeof e != "string" || !p.hasOwnProperty(e))
      throw new TypeError(_);
    if (!(r instanceof Uint8Array))
      throw new TypeError("bytesToString() expects Uint8Array");
    return p[e].encode(r);
  };
  o.bytesToString = A, o.str = o.bytesToString;
  const W = (e, r) => {
    if (!p.hasOwnProperty(e))
      throw new TypeError(_);
    if (typeof r != "string")
      throw new TypeError("stringToBytes() expects string");
    return p[e].decode(r);
  };
  o.stringToBytes = W, o.bytes = o.stringToBytes;
})(ue);
BigInt(1e3), BigInt(1e6), BigInt(1e9), BigInt(1e12);
BigInt("2100000000000000000");
BigInt(1e11);
const X = {
  payment_hash: 1,
  payment_secret: 16,
  description: 13,
  payee: 19,
  description_hash: 23,
  // commit to longer descriptions (used by lnurl-pay)
  expiry: 6,
  // default: 3600 (1 hour)
  min_final_cltv_expiry: 24,
  // default: 9
  fallback_address: 9,
  route_hint: 3,
  // for extra routing info (private etc.)
  feature_bits: 5,
  metadata: 27
};
for (let o = 0, v = Object.keys(X); o < v.length; o++)
  v[o], X[v[o]].toString();
const V = async (o) => {
  const v = "https://getalby.com/api/rates/" + o.toLowerCase() + ".json";
  return (await (await fetch(v)).json()).rate_float / 1e8;
}, Y = async ({ satoshi: o, currency: v }) => {
  const l = await V(v);
  return Number(o) * l;
};
var he = { __proto__: null, getFiatBtcRate: V, getFiatValue: Y, getSatoshiValue: async ({ amount: o, currency: v }) => {
  const l = await V(v);
  return Math.floor(Number(o) / l);
}, getFormattedFiatValue: async ({ satoshi: o, currency: v, locale: l }) => (l || (l = "en"), (await Y({ satoshi: o, currency: v })).toLocaleString(l, { style: "currency", currency: v })) };
function we({
  displaySymbol: o,
  price: v,
  formattedPrice: l
}) {
  const [w, m] = K.useState("loading...");
  return K.useEffect(() => {
    (async () => {
      const b = await he.getFiatValue({
        satoshi: v,
        currency: "USD"
      });
      m(`$${b.toFixed(2)}`);
    })();
  }, [v]), /* @__PURE__ */ J(ne, {
    content: w,
    children: /* @__PURE__ */ oe("div", {
      className: "inline-flex items-center justify-center",
      children: [o && /* @__PURE__ */ J(te, {
        className: "h-4 w-4"
      }), l]
    })
  });
}
export {
  we as AlbyPriceComponent
};
