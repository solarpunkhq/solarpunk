import { aM as L, aN as V, aO as D, aP as G, aQ as Y, aR as j, aS as X, aT as q, aU as re, aV as ie, aW as oe, aX as ae } from "./index-6PQ0n_zn.js";
function b(t, e, n, s = { passive: !0 }) {
  return t.addEventListener(e, n, s), () => t.removeEventListener(e, n);
}
const ce = (t) => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1;
function Z(t, e = "page") {
  return {
    point: {
      x: t[e + "X"],
      y: t[e + "Y"]
    }
  };
}
const ue = (t) => (e) => ce(e) && t(e, Z(e));
function T(t, e, n, s) {
  return b(t, e, ue(n), s);
}
function $(t) {
  let e = null;
  return () => {
    const n = () => {
      e = null;
    };
    return e === null ? (e = t, n) : !1;
  };
}
const _ = $("dragHorizontal"), J = $("dragVertical");
function le(t) {
  let e = !1;
  if (t === "y")
    e = J();
  else if (t === "x")
    e = _();
  else {
    const n = _(), s = J();
    n && s ? e = () => {
      n(), s();
    } : (n && n(), s && s());
  }
  return e;
}
function ee() {
  const t = le(!0);
  return t ? (t(), !1) : !0;
}
class w {
  constructor(e) {
    this.isMounted = !1, this.node = e;
  }
  update() {
  }
}
function Q(t, e) {
  const n = "pointer" + (e ? "enter" : "leave"), s = "onHover" + (e ? "Start" : "End"), o = (a, l) => {
    if (a.type === "touch" || ee())
      return;
    const c = t.getProps();
    t.animationState && c.whileHover && t.animationState.setActive("whileHover", e), c[s] && V.update(() => c[s](a, l));
  };
  return T(t.current, n, o, {
    passive: !t.getProps()[s]
  });
}
class he extends w {
  mount() {
    this.unmount = L(Q(this.node, !0), Q(this.node, !1));
  }
  unmount() {
  }
}
class de extends w {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = L(b(this.node.current, "focus", () => this.onFocus()), b(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const te = (t, e) => e ? t === e ? !0 : te(t, e.parentElement) : !1;
function H(t, e) {
  if (!e)
    return;
  const n = new PointerEvent("pointer" + t);
  e(n, Z(n));
}
class fe extends w {
  constructor() {
    super(...arguments), this.removeStartListeners = D, this.removeEndListeners = D, this.removeAccessibleListeners = D, this.startPointerPress = (e, n) => {
      if (this.removeEndListeners(), this.isPressing)
        return;
      const s = this.node.getProps(), a = T(window, "pointerup", (c, i) => {
        if (!this.checkPressEnd())
          return;
        const { onTap: r, onTapCancel: u } = this.node.getProps();
        V.update(() => {
          te(this.node.current, c.target) ? r && r(c, i) : u && u(c, i);
        });
      }, { passive: !(s.onTap || s.onPointerUp) }), l = T(window, "pointercancel", (c, i) => this.cancelPress(c, i), { passive: !(s.onTapCancel || s.onPointerCancel) });
      this.removeEndListeners = L(a, l), this.startPress(e, n);
    }, this.startAccessiblePress = () => {
      const e = (a) => {
        if (a.key !== "Enter" || this.isPressing)
          return;
        const l = (c) => {
          c.key !== "Enter" || !this.checkPressEnd() || H("up", (i, r) => {
            const { onTap: u } = this.node.getProps();
            u && V.update(() => u(i, r));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = b(this.node.current, "keyup", l), H("down", (c, i) => {
          this.startPress(c, i);
        });
      }, n = b(this.node.current, "keydown", e), s = () => {
        this.isPressing && H("cancel", (a, l) => this.cancelPress(a, l));
      }, o = b(this.node.current, "blur", s);
      this.removeAccessibleListeners = L(n, o);
    };
  }
  startPress(e, n) {
    this.isPressing = !0;
    const { onTapStart: s, whileTap: o } = this.node.getProps();
    o && this.node.animationState && this.node.animationState.setActive("whileTap", !0), s && V.update(() => s(e, n));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !ee();
  }
  cancelPress(e, n) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel: s } = this.node.getProps();
    s && V.update(() => s(e, n));
  }
  mount() {
    const e = this.node.getProps(), n = T(this.node.current, "pointerdown", this.startPointerPress, { passive: !(e.onTapStart || e.onPointerStart) }), s = b(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = L(n, s);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const M = /* @__PURE__ */ new WeakMap(), K = /* @__PURE__ */ new WeakMap(), pe = (t) => {
  const e = M.get(t.target);
  e && e(t);
}, me = (t) => {
  t.forEach(pe);
};
function ve({ root: t, ...e }) {
  const n = t || document;
  K.has(n) || K.set(n, {});
  const s = K.get(n), o = JSON.stringify(e);
  return s[o] || (s[o] = new IntersectionObserver(me, { root: t, ...e })), s[o];
}
function Pe(t, e, n) {
  const s = ve(e);
  return M.set(t, n), s.observe(t), () => {
    M.delete(t), s.unobserve(t);
  };
}
const ge = {
  some: 0,
  all: 1
};
class Ae extends w {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(), { root: n, margin: s, amount: o = "some", once: a } = e, l = {
      root: n ? n.current : void 0,
      rootMargin: s,
      threshold: typeof o == "number" ? o : ge[o]
    }, c = (i) => {
      const { isIntersecting: r } = i;
      if (this.isInView === r || (this.isInView = r, a && !r && this.hasEnteredView))
        return;
      r && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", r);
      const { onViewportEnter: u, onViewportLeave: p } = this.node.getProps(), m = r ? u : p;
      m && m(i);
    };
    return Pe(this.node.current, l, c);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: e, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(ye(e, n)) && this.startObserver();
  }
  unmount() {
  }
}
function ye({ viewport: t = {} }, { viewport: e = {} } = {}) {
  return (n) => t[n] !== e[n];
}
const be = {
  inView: {
    Feature: Ae
  },
  tap: {
    Feature: fe
  },
  focus: {
    Feature: de
  },
  hover: {
    Feature: he
  }
};
function ne(t, e) {
  if (!Array.isArray(e))
    return !1;
  const n = e.length;
  if (n !== t.length)
    return !1;
  for (let s = 0; s < n; s++)
    if (e[s] !== t[s])
      return !1;
  return !0;
}
function B(t, e, n = {}) {
  const s = G(t, e, n.custom);
  let { transition: o = t.getDefaultTransition() || {} } = s || {};
  n.transitionOverride && (o = n.transitionOverride);
  const a = s ? () => Promise.all(Y(t, s, n)) : () => Promise.resolve(), l = t.variantChildren && t.variantChildren.size ? (i = 0) => {
    const { delayChildren: r = 0, staggerChildren: u, staggerDirection: p } = o;
    return we(t, e, r + i, u, p, n);
  } : () => Promise.resolve(), { when: c } = o;
  if (c) {
    const [i, r] = c === "beforeChildren" ? [a, l] : [l, a];
    return i().then(() => r());
  } else
    return Promise.all([a(), l(n.delay)]);
}
function we(t, e, n = 0, s = 0, o = 1, a) {
  const l = [], c = (t.variantChildren.size - 1) * s, i = o === 1 ? (r = 0) => r * s : (r = 0) => c - r * s;
  return Array.from(t.variantChildren).sort(Se).forEach((r, u) => {
    r.notify("AnimationStart", e), l.push(B(r, e, {
      ...a,
      delay: n + i(u)
    }).then(() => r.notify("AnimationComplete", e)));
  }), Promise.all(l);
}
function Se(t, e) {
  return t.sortNodePosition(e);
}
function Ce(t, e, n = {}) {
  t.notify("AnimationStart", e);
  let s;
  if (Array.isArray(e)) {
    const o = e.map((a) => B(t, a, n));
    s = Promise.all(o);
  } else if (typeof e == "string")
    s = B(t, e, n);
  else {
    const o = typeof e == "function" ? G(t, e, n.custom) : e;
    s = Promise.all(Y(t, o, n));
  }
  return s.then(() => t.notify("AnimationComplete", e));
}
const Ve = [...q].reverse(), Le = q.length;
function ke(t) {
  return (e) => Promise.all(e.map(({ animation: n, options: s }) => Ce(t, n, s)));
}
function Te(t) {
  let e = ke(t);
  const n = xe();
  let s = !0;
  const o = (i, r) => {
    const u = G(t, r);
    if (u) {
      const { transition: p, transitionEnd: m, ...v } = u;
      i = { ...i, ...v, ...m };
    }
    return i;
  };
  function a(i) {
    e = i(t);
  }
  function l(i, r) {
    const u = t.getProps(), p = t.getVariantContext(!0) || {}, m = [], v = /* @__PURE__ */ new Set();
    let g = {}, R = 1 / 0;
    for (let A = 0; A < Le; A++) {
      const f = Ve[A], h = n[f], P = u[f] !== void 0 ? u[f] : p[f], O = re(P), x = f === r ? h.isActive : null;
      x === !1 && (R = A);
      let k = P === p[f] && P !== u[f] && O;
      if (k && s && t.manuallyAnimateOnMount && (k = !1), h.protectedKeys = { ...g }, // If it isn't active and hasn't *just* been set as inactive
      !h.isActive && x === null || // If we didn't and don't have any defined prop for this animation type
      !P && !h.prevProp || // Or if the prop doesn't define an animation
      j(P) || typeof P == "boolean")
        continue;
      const N = Oe(h.prevProp, P);
      let I = N || // If we're making this variant active, we want to always make it active
      f === r && h.isActive && !k && O || // If we removed a higher-priority variant (i is in reverse order)
      A > R && O;
      const U = Array.isArray(P) ? P : [P];
      let S = U.reduce(o, {});
      x === !1 && (S = {});
      const { prevResolvedValues: W = {} } = h, se = {
        ...W,
        ...S
      }, F = (d) => {
        I = !0, v.delete(d), h.needsAnimating[d] = !0;
      };
      for (const d in se) {
        const C = S[d], E = W[d];
        g.hasOwnProperty(d) || (C !== E ? X(C) && X(E) ? !ne(C, E) || N ? F(d) : h.protectedKeys[d] = !0 : C !== void 0 ? F(d) : v.add(d) : C !== void 0 && v.has(d) ? F(d) : h.protectedKeys[d] = !0);
      }
      h.prevProp = P, h.prevResolvedValues = S, h.isActive && (g = { ...g, ...S }), s && t.blockInitialAnimation && (I = !1), I && !k && m.push(...U.map((d) => ({
        animation: d,
        options: { type: f, ...i }
      })));
    }
    if (v.size) {
      const A = {};
      v.forEach((f) => {
        const h = t.getBaseTarget(f);
        h !== void 0 && (A[f] = h);
      }), m.push({ animation: A });
    }
    let z = !!m.length;
    return s && u.initial === !1 && !t.manuallyAnimateOnMount && (z = !1), s = !1, z ? e(m) : Promise.resolve();
  }
  function c(i, r, u) {
    var p;
    if (n[i].isActive === r)
      return Promise.resolve();
    (p = t.variantChildren) === null || p === void 0 || p.forEach((v) => {
      var g;
      return (g = v.animationState) === null || g === void 0 ? void 0 : g.setActive(i, r);
    }), n[i].isActive = r;
    const m = l(u, i);
    for (const v in n)
      n[v].protectedKeys = {};
    return m;
  }
  return {
    animateChanges: l,
    setActive: c,
    setAnimateFunction: a,
    getState: () => n
  };
}
function Oe(t, e) {
  return typeof e == "string" ? e !== t : Array.isArray(e) ? !ne(e, t) : !1;
}
function y(t = !1) {
  return {
    isActive: t,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function xe() {
  return {
    animate: y(!0),
    whileInView: y(),
    whileHover: y(),
    whileTap: y(),
    whileDrag: y(),
    whileFocus: y(),
    exit: y()
  };
}
class Ie extends w {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(e) {
    super(e), e.animationState || (e.animationState = Te(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    this.unmount(), j(e) && (this.unmount = e.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    e !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
  }
}
let Fe = 0;
class Ee extends w {
  constructor() {
    super(...arguments), this.id = Fe++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: e, onExitComplete: n, custom: s } = this.node.presenceContext, { isPresent: o } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === o)
      return;
    const a = this.node.animationState.setActive("exit", !e, { custom: s ?? this.node.getProps().custom });
    n && !e && a.then(() => n(this.id));
  }
  mount() {
    const { register: e } = this.node.presenceContext || {};
    e && (this.unmount = e(this.id));
  }
  unmount() {
  }
}
const De = {
  animation: {
    Feature: Ie
  },
  exit: {
    Feature: Ee
  }
}, He = (t, e) => ie(t) ? new oe(e, { enableHardwareAcceleration: !1 }) : new ae(e, { enableHardwareAcceleration: !0 }), Me = {
  renderer: He,
  ...De,
  ...be
};
export {
  Me as default
};
