import type { ClassProp, ClassValue, OmitUndefined, StringToBoolean } from "./types";
export declare type VariantProps<Component extends (...args: any) => any> = Omit<OmitUndefined<Parameters<Component>[0]>, "class" | "className">;
export declare type CxOptions = ClassValue[];
export declare type CxReturn = string;
export declare const cx: <T extends CxOptions>(...classes: T) => CxReturn;
declare type ConfigSchema = Record<string, Record<string, ClassValue>>;
declare type ConfigVariants<T extends ConfigSchema> = {
    [Variant in keyof T]?: StringToBoolean<keyof T[Variant]> | null;
};
declare type ConfigVariantsMulti<T extends ConfigSchema> = {
    [Variant in keyof T]?: StringToBoolean<keyof T[Variant]> | StringToBoolean<keyof T[Variant]>[];
};
declare type Config<T> = T extends ConfigSchema ? {
    variants?: T;
    defaultVariants?: ConfigVariants<T>;
    compoundVariants?: (T extends ConfigSchema ? (ConfigVariants<T> | ConfigVariantsMulti<T>) & ClassProp : ClassProp)[];
} : never;
declare type Props<T> = T extends ConfigSchema ? ConfigVariants<T> & ClassProp : ClassProp;
export declare const cva: <T>(base?: ClassValue, config?: Config<T> | undefined) => (props?: Props<T> | undefined) => string;
export {};
