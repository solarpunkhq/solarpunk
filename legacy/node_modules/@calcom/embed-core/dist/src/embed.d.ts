import type { InterfaceWithParent, interfaceWithParent, PrefillAndIframeAttrsConfig } from "./embed-iframe";
import { SdkActionManager } from "./sdk-action-manager";
import type { EventData, EventDataMap } from "./sdk-action-manager";
import type { UiConfig } from "./types";
export type { PrefillAndIframeAttrsConfig } from "./embed-iframe";
type Rest<T extends any[]> = T extends [any, ...infer U] ? U : never;
export type Message = {
    originator: string;
    method: keyof InterfaceWithParent;
    arg: InterfaceWithParent[keyof InterfaceWithParent];
};
declare module "*.css";
type Namespace = string;
type Config = {
    calOrigin: string;
    debug?: boolean;
    uiDebug?: boolean;
};
type InitArgConfig = Partial<Config> & {
    origin?: string;
};
type DoInIframeArg = {
    [K in keyof typeof interfaceWithParent]: {
        method: K;
        arg?: Parameters<(typeof interfaceWithParent)[K]>[0];
    };
}[keyof typeof interfaceWithParent];
type SingleInstructionMap = {
    [K in keyof CalApi]: CalApi[K] extends (...args: never[]) => void ? [K, ...Parameters<CalApi[K]>] : never;
};
type SingleInstruction = SingleInstructionMap[keyof SingleInstructionMap];
export type Instruction = SingleInstruction | SingleInstruction[];
export type InstructionQueue = Instruction[];
export declare class Cal {
    iframe?: HTMLIFrameElement;
    __config: Config;
    modalBox?: Element;
    inlineEl?: Element;
    namespace: string;
    actionManager: SdkActionManager;
    iframeReady: boolean;
    iframeDoQueue: DoInIframeArg[];
    api: CalApi;
    isPerendering?: boolean;
    static actionsManagers: Record<Namespace, SdkActionManager>;
    static getQueryObject(config: PrefillAndIframeAttrsConfig): Record<string, string | string[] | Record<string, string>> & {
        iframeAttrs?: (Record<string, string> & {
            id?: string | undefined;
        }) | undefined;
        layout?: import("./types").BookerLayouts | undefined;
        "ui.color-scheme"?: string | undefined;
        theme?: import("./types").EmbedThemeConfig | undefined;
    } & {
        guest?: string | string[] | undefined;
    };
    processInstruction(instructionAsArgs: IArguments | Instruction): SingleInstruction[] | undefined;
    processQueue(queue: IArguments[]): void;
    /**
     * Iframe is added invisible and shown only after color-scheme is set by the embedded calLink to avoid flash of non-transparent(white/black) background
     */
    createIframe({ calLink, queryObject, calOrigin, }: {
        calLink: string;
        queryObject?: PrefillAndIframeAttrsConfig & {
            guest?: string | string[];
        };
        calOrigin: string | null;
    }): HTMLIFrameElement;
    getConfig(): Config;
    doInIframe(doInIframeArg: DoInIframeArg): void;
    constructor(namespace: string, q: IArguments[]);
}
declare class CalApi {
    cal: Cal;
    static initializedNamespaces: string[];
    modalUid?: string;
    preloadedModalUid?: string;
    constructor(cal: Cal);
    init(namespaceOrConfig?: string | InitArgConfig, config?: InitArgConfig): void;
    /**
     * It is an instruction that adds embed iframe inline as last child of the element
     */
    inline({ calLink, elementOrSelector, config, }: {
        calLink: string;
        elementOrSelector: string | HTMLElement;
        config?: PrefillAndIframeAttrsConfig;
    }): void;
    floatingButton({ calLink, buttonText, hideButtonIcon, attributes, buttonPosition, buttonColor, buttonTextColor, calOrigin, config, }: {
        calLink: string;
        buttonText?: string;
        attributes?: Record<"id", string> & Record<string | "id", string>;
        hideButtonIcon?: boolean;
        buttonPosition?: "bottom-left" | "bottom-right";
        buttonColor?: string;
        buttonTextColor?: string;
        calOrigin?: string;
        config?: PrefillAndIframeAttrsConfig;
    }): void;
    modal({ calLink, config, calOrigin, __prerender, }: {
        calLink: string;
        config?: PrefillAndIframeAttrsConfig;
        calOrigin?: string;
        __prerender?: boolean;
    }): void;
    private handleClose;
    on<T extends keyof EventDataMap>({ action, callback, }: {
        action: T;
        callback: (arg0: CustomEvent<EventData<T>>) => void;
    }): void;
    off<T extends keyof EventDataMap>({ action, callback, }: {
        action: T;
        callback: (arg0: CustomEvent<EventData<T>>) => void;
    }): void;
    /**
     *
     * type is provided and prerenderIframe not set. We would assume prerenderIframe to be true
     * type is provided and prerenderIframe set to false. We would ignore the type and preload assets only
     * type is not provided and prerenderIframe set to true. We would throw error as we don't know what to prerender
     * type is not provided and prerenderIframe set to false. We would preload assets only
     */
    preload({ calLink, type, options, }: {
        calLink: string;
        type?: "modal" | "floatingButton";
        options?: {
            prerenderIframe?: boolean;
        };
    }): void;
    prerender({ calLink, type }: {
        calLink: string;
        type: "modal" | "floatingButton";
    }): void;
    ui(uiConfig: UiConfig): void;
}
export interface GlobalCalWithoutNs {
    <T extends keyof SingleInstructionMap>(methodName: T, ...arg: Rest<SingleInstructionMap[T]>): void;
    /** Marks that the embed.js is loaded. Avoids re-downloading it. */
    loaded?: boolean;
    /** Maintains a queue till the time embed.js isn't loaded */
    q: IArguments[];
    /** If user registers multiple namespaces, those are available here */
    instance?: Cal;
    __css?: string;
    fingerprint?: string;
    __logQueue?: unknown[];
}
type GlobalCalWithNs = GlobalCalWithoutNs & {
    ns: Record<string, GlobalCalWithoutNs>;
};
export type GlobalCal = GlobalCalWithNs;
declare global {
    interface Window {
        Cal: GlobalCal;
    }
}
export interface CalWindow extends Window {
    Cal: GlobalCal;
}
//# sourceMappingURL=embed.d.ts.map